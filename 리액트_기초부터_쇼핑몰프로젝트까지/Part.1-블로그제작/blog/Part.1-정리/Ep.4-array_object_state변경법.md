# array , object state 변경법

<br>

## 일단 글 수정 버튼 만들기

```js
function App() {
    let [글제목, 글제목변경] = useState(['남자코트 추천', '강남 우동맛집', '파이썬 독학']);

    return (
        <button
            onClick={() => {
                글제목변경(['여자코트 추천', '강남 우동맛집', '파이썬 독학']);
            }}
        >
            {' '}
            수정버튼{' '}
        </button>
    );
}
```

이러면 사실상 끝입니다. state 변경함수는 () 안에 넣은걸로 기존 state 갈아치워주니까 저렇게 하면 됩니다.

<br>

### 글제목변경('여자코트추천') 이건 왜 안되나요

기존 state를 갈아치워주기 때문입니다. <br><br>
['남자코트 추천','강남 우동맛집','파이썬 독학'] 이걸 <br>
['여자코트 추천','강남 우동맛집','파이썬 독학'] 이렇게 하고 싶으면 <br>
['여자코트 추천','강남 우동맛집','파이썬 독학'] 이렇게 바꾸는 부분 포함해서 다 넣어야 합니다. <br><br>

## 약간 프로그래머 스타일로 다시 만들어보면

기존 state 다 복붙하지막로 기존 state를 첫 글만 살짝 바꿔서 state 변경함수에 집어넣는 식으로 해야 합니다. <br>

```js
function App() {
    let [글제목, 글제목변경] = useState(['남자코트 추천', '강남 우동맛집', '파이썬 독학']);

    return (
        <button
            onClick={() => {
                글제목[0] = '여자코트 추천';
                글제목변경(글제목);
            }}
        >
            {' '}
            수정버튼{' '}
        </button>
    );
}
```

이렇게 해도 되긴합니다. <br>
array 자료 안에 n번째 항목을 변경하고 싶으면 <br>
array자료[n] = '바꿀값' 이렇게 하면 됩니다. 혹은 <br>

```js
function App() {
    let [글제목, 글제목변경] = useState(['남자코트 추천', '강남 우동맛집', '파이썬 독학']);

    return (
        <button
            onClick={() => {
                let copy = 글제목;
                copy[0] = '여자코트 추천';
                글제목변경(copy);
            }}
        >
            {' '}
            수정버튼{' '}
        </button>
    );
}
```

이렇게 array,object 자료 다룰 때는 원본 데이터를 직접 조작보다는 **기존 값은 보존해주는 식으로 코드 짜는게** 좋은 관습입니다. <br>
그래서 let copy 같은 변수에다가 기존 array 복사해놓고 그걸 조작하는 식으로 코드짜면 더 안전합니다. <br>

근데 동작 안하는데요.?

<br>

```js
function App() {
    let [글제목, 글제목변경] = useState(['남자코트 추천', '강남 우동맛집', '파이썬 독학']);

    return (
        <button
            onClick={() => {
                let copy = [...글제목];
                copy[0] = '여자코트 추천';
                글제목변경(copy);
            }}
        >
            {' '}
            수정버튼{' '}
        </button>
    );
}
```

[...글제목] 으로 바꾸면 동작합니다. 원리가 무엇일까요.

<br><br>

## state 변경함수 동작원리

state 변경함수를 쓸 때 <br>
기존 state === 신규 state 이렇게 먼저 검사해봅니다. <br>
그래서 같으면 state 변경을 해주지 않습니다. <br>

그래서 위 코드에서도 글제목변경(copy) 해도 <br>
copy 라는 변수가 기존 state 와 같아서 변경을 안해주는 것입니다. <br><br>

### ?? copy 라는 변수랑 기존 state랑 안에 있는 자료가 다른데 왜 같다고 함?

기존 state는 남자코트 추천 <br>
copy에는 여자코트 추천이 들어있지만 <br>
실은 기존state === copy 비교해보면 같다고 나옵니다. 왜일까요.

<br><br>

## array/object 동작원리

자바스크립트는 array/object 자료를 하나 만들면 <br>
예를 들어서 `let arr = [1,2,3]` 이렇게 만들면 <br>
[1,2,3] 자료는 램이라는 가상 공간에 몰래 저장이 되고 <br>
let arr 변수엔 그 자료가 어디있는지 가리키는 화살표만 담겨 있습니다.

<br>

그래서 array/object 자료를 복사하면 이상한 일이 일어나는데

```js
let data1 = [1, 2, 3];
let data2 = data1; //복사문법임
```

이런식으로 사용하면 복사가 됩니다. <br>
data1에 있던 자료를 data2에 복사한다는 뜻입니다. <br>
그럼 data2 출력해보면 [1,2,3] 이게 잘 나옵니다. <br>
근데 data1과 data2는 각각 [1,2,3] 을 별개로 저장하는게 아니라 <br>

data1과 data2는 똑같은 값을 공유합니다. <br>
data1을 변경하면 data2도 자도을 변경됩니다. <br>

왜 그러냐면 변수에는 화살표만 저장되니까요.<br>
그래서 data1, data2는 똑같은 화살표 즉, 같은 자료를 가리키게 됩니다. <br><br>

```js
let data1 = [1, 2, 3];
let data2 = data1; //복사
data2[0] = 1000; //data2 내부 변경
console.log(data2 === data1); //true 나올듯
```

그래서 같은 화살표를 가지고 있는 변수 끼리는 등호로 비교해도 똑같다고 나옵니다. 자세한건 javascript reference data type 검색!

<br>

```js
let copy = 글제목;
copy[0] = '여자코트 추천';
글제목변경(copy);
```

그래서 아까처럼 이렇게하면 <br>
컴퓨터는 copy와 기존 글제목 state는 똑같다고 생각하기 때문에 (화살표가 똑같아서) state 변경을 안해줍니다. <br>

```js
let copy = [...글제목];
copy[0] = '여자코트 추천';
글제목변경(copy);
```

이러면 잗룁니다. 화살표가 달라지는 문법이라 그렇습니다.

<br><br>

### 점 3개뭐임

spread operator 라고 하는 문법인데 <br>
array 나 object 자료형 왼쪽에 붙일 수 있으며 <br>
뜻은 별거없고 괄호를 벗겨주세요~ 라는 뜻입니다. <br><br>
...[1,2,3] 쓰면 그 자리에 1,2,3 이 남습니다. <br>
그냥 괄호 벗기기용 연산자입니다. <br>
근데 두번째 용도도 있는데 array나 object 자료형을 복사할 때 많이 사용합니다.

```js
let data1 = [1, 2, 3];
let data2 = [...data1];
console.log(data1 === data2); //false 나올듯
```

그냥 data1에 있던 자료들을 괄호 벗긴담에 다시 array로 만들어주세요` 라고 사용하면 화살표가 달라집니다. 새로운 array로 인식해서요. <br>

그래서 그렇게하면 화살표가 다른 완전 독립적인 array 복사본을 생성해줄 수 있습니다. <br>
object 자료형도 마찬가지입니다. <br>
그리고 독립적인 사본을 shallow copy 아니면 deep copy 라고 합니다.

<br><br>

## 정리하자면

리액트에서 array/object state 를 수정하고 싶으면 <br>
독립적인 카피본 만들어서 수정하는게 좋습니다. <br>
[...기존state] <br>
{...기존state}<br>
이렇게하면 독립적인 카피가 하나 생성됩니다. <br>

1. 수정하고 싶은 state의 deep/shallow 카피본을 하나 생성
2. 카피본을 입맛에 맞게 수정
3. 카피본을 변경함수에 파라미터로 동작
